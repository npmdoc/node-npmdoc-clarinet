<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/dscape/clarinet">clarinet (v0.11.0)</a>
</h1>
<h4>SAX based evented streaming JSON parser in JavaScript (browser and node)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet">module clarinet</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">clarinet.</span>DEBUG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">clarinet.</span>INFO</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser">
            function <span class="apidocSignatureSpan">clarinet.</span>CParser
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.close">
            function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.end">
            function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.resume">
            function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.write">
            function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.write
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream">
            function <span class="apidocSignatureSpan">clarinet.</span>CStream
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.destroy">
            function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.end">
            function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.on">
            function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.on
            <span class="apidocSignatureSpan">(ev, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.write">
            function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.createStream">
            function <span class="apidocSignatureSpan">clarinet.</span>createStream
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.parser">
            function <span class="apidocSignatureSpan">clarinet.</span>parser
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">clarinet.</span>MAX_BUFFER_LENGTH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">clarinet.</span>EVENTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">clarinet.</span>STATE</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CParser">module clarinet.CParser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.CParser">
            function <span class="apidocSignatureSpan">clarinet.</span>CParser
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CParser.prototype">module clarinet.CParser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.close">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.end">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.resume">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.write">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CParser.prototype.close">module clarinet.CParser.prototype.close</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.close.close">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CParser.prototype.end">module clarinet.CParser.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.end.end">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CParser.prototype.resume">module clarinet.CParser.prototype.resume</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.resume.resume">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CParser.prototype.write">module clarinet.CParser.prototype.write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CParser.prototype.write.write">
            function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>write
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CStream">module clarinet.CStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.CStream">
            function <span class="apidocSignatureSpan">clarinet.</span>CStream
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CStream.prototype">module clarinet.CStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.destroy">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.end">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.on">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.write">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CStream.prototype.destroy">module clarinet.CStream.prototype.destroy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.destroy.destroy">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CStream.prototype.end">module clarinet.CStream.prototype.end</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.end.end">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>end
            <span class="apidocSignatureSpan">(chunk)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CStream.prototype.on">module clarinet.CStream.prototype.on</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.on.on">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>on
            <span class="apidocSignatureSpan">(ev, handler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.CStream.prototype.write">module clarinet.CStream.prototype.write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.CStream.prototype.write.write">
            function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>write
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.createStream">module clarinet.createStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.createStream.createStream">
            function <span class="apidocSignatureSpan">clarinet.</span>createStream
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.clarinet.parser">module clarinet.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.clarinet.parser.parser">
            function <span class="apidocSignatureSpan">clarinet.</span>parser
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet" id="apidoc.module.clarinet">module clarinet</a></h1>






    <h2>
        <a href="#apidoc.element.clarinet.CParser" id="apidoc.element.clarinet.CParser">
        function <span class="apidocSignatureSpan">clarinet.</span>CParser
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CParser(opt) {
  if (!(this instanceof CParser)) return new CParser (opt);

  var parser = this;
  clearBuffers(parser);
  parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;
  parser.q        = parser.c = parser.p = "";
  parser.opt      = opt || {};
  parser.closed   = parser.closedRoot = parser.sawRoot = false;
  parser.tag      = parser.error = null;
  parser.state    = S.BEGIN;
  parser.stack    = new Array();
  // mostly just for error reporting
  parser.position = parser.column = 0;
  parser.line     = 1;
  parser.slashed  = false;
  parser.unicodeI = 0;
  parser.unicodeS = null;
  parser.depth    = 0;
  emit(parser, "onready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.close" id="apidoc.element.clarinet.CParser.prototype.close">
        function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CParser.prototype.close = function () { return this.write(null); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.end" id="apidoc.element.clarinet.CParser.prototype.end">
        function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CParser.prototype.end = function () { end(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.resume" id="apidoc.element.clarinet.CParser.prototype.resume">
        function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CParser.prototype.resume = function () { this.error = null; return this; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.write" id="apidoc.element.clarinet.CParser.prototype.write">
        function <span class="apidocSignatureSpan">clarinet.</span>CParser.prototype.write
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(chunk) {
  var parser = this;
  if (this.error) throw this.error;
  if (parser.closed) return error(parser,
    "Cannot write after close. Assign an onready handler.");
  if (chunk === null) return end(parser);
  var i = 0, c = chunk[0], p = parser.p;
  if (clarinet.DEBUG) console.log('write -&gt; [' + chunk + ']');
  while (c) {
    p = c;
    parser.c = c = chunk.charAt(i++);
    // if chunk doesnt have next, like streaming char by char
    // this way we need to check if previous is really previous
    // if not we need to reset to what the parser says is the previous
    // from buffer
    if(p !== c ) parser.p = p;
    else p = parser.p;

    if(!c) break;

    if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);
    parser.position ++;
    if (c === "\n") {
      parser.line ++;
      parser.column = 0;
    } else parser.column ++;
    switch (parser.state) {

      case S.BEGIN:
        if (c === "{") parser.state = S.OPEN_OBJECT;
        else if (c === "[") parser.state = S.OPEN_ARRAY;
        else if (c !== '\r' &amp;&amp; c !== '\n' &amp;&amp; c !== ' ' &amp;&amp; c !== '\t')
          error(parser, "Non-whitespace before {[.");
      continue;

      case S.OPEN_KEY:
      case S.OPEN_OBJECT:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);
        else {
          if(c === '}') {
            emit(parser, 'onopenobject');
            this.depth++;
            emit(parser, 'oncloseobject');
            this.depth--;
            parser.state = parser.stack.pop() || S.VALUE;
            continue;
          } else  parser.stack.push(S.CLOSE_OBJECT);
        }
        if(c === '"') parser.state = S.STRING;
        else error(parser, "Malformed object key should start with \"");
      continue;

      case S.CLOSE_KEY:
      case S.CLOSE_OBJECT:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';
        if(c===':') {
          if(parser.state === S.CLOSE_OBJECT) {
            parser.stack.push(S.CLOSE_OBJECT);
            closeValue(parser, 'onopenobject');
             this.depth++;
          } else closeValue(parser, 'onkey');
          parser.state  = S.VALUE;
        } else if (c==='}') {
          emitNode(parser, 'oncloseobject');
          this.depth--;
          parser.state = parser.stack.pop() || S.VALUE;
        } else if(c===',') {
          if(parser.state === S.CLOSE_OBJECT)
            parser.stack.push(S.CLOSE_OBJECT);
          closeValue(parser);
          parser.state  = S.OPEN_KEY;
        } else error(parser, 'Bad object');
      continue;

      case S.OPEN_ARRAY: // after an array there always a value
      case S.VALUE:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        if(parser.state===S.OPEN_ARRAY) {
          emit(parser, 'onopenarray');
          this.depth++;
          parser.state = S.VALUE;
          if(c === ']') {
            emit(parser, 'onclosearray');
            this.depth--;
            parser.state = parser.stack.pop() || S.VALUE;
            continue;
          } else {
            parser.stack.push(S.CLOSE_ARRAY);
          }
        }
             if(c === '"') parser.state = S.STRING;
        else if(c === '{') parser.state = S.OPEN_OBJECT;
        else if(c === '[') parser.state = S.OPEN_ARRAY;
        else if(c === 't') parser.state = S.TRUE;
        else if(c === 'f') parser.state = S.FALSE;
        else if(c === 'n') parser.state = S.NULL;
        else if(c === '-') { // keep and continue
          parser.numberNode += c;
        } else if(c==='0') {
          parser.numberNode += c;
          parser.state = S.NUMBER_DIGIT;
        } else if('123456789'.indexOf(c) !== -1) {
          parser.numberNode += c;
          parser.state = S.NUMBER_DIGIT;
        } else               error(parser, "Bad value");
      continue;

      case S.CLOSE_ARRAY:
        if(c===',') {
          parser.stack.push(S.CLOSE_ARRAY);
          closeValue(parser, 'onval ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream" id="apidoc.element.clarinet.CStream">
        function <span class="apidocSignatureSpan">clarinet.</span>CStream
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CStream(opt) {
  if (!(this instanceof CStream)) return new CStream(opt);

  this._parser = new CParser(opt);
  this.writable = true;
  this.readable = true;

  //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer`
and not throw an error
  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
  this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary
 is reached
  this.string = '';

  var me = this;
  Stream.apply(me);

  this._parser.onend = function () { me.emit("end"); };
  this._parser.onerror = function (er) {
    me.emit("error", er);
    me._parser.error = null;
  };

  streamWraps.forEach(function (ev) {
    Object.defineProperty(me, "on" + ev,
      { get          : function () { return me._parser["on" + ev]; }
      , set          : function (h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser["on"+ev] = h;
            return h;
          }
          me.on(ev, h);
        }
      , enumerable   : true
      , configurable : false
      });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.destroy" id="apidoc.element.clarinet.CStream.prototype.destroy">
        function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CStream.prototype.destroy = function () {
  clearBuffers(this._parser);
  this.emit("close");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.end" id="apidoc.element.clarinet.CStream.prototype.end">
        function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CStream.prototype.end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) this._parser.write(chunk.toString());
  this._parser.end();
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.on" id="apidoc.element.clarinet.CStream.prototype.on">
        function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.on
        <span class="apidocSignatureSpan">(ev, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CStream.prototype.on = function (ev, handler) {
  var me = this;
  if (!me._parser["on"+ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser["on"+ev] = function () {
      var args = arguments.length === 1 ? [arguments[0]]
               : Array.apply(null, arguments);
      args.splice(0, 0, ev);
      me.emit.apply(me, args);
    };
  }
  return Stream.prototype.on.call(me, ev, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.write" id="apidoc.element.clarinet.CStream.prototype.write">
        function <span class="apidocSignatureSpan">clarinet.</span>CStream.prototype.write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CStream.prototype.write = function (data) {
  data = new Buffer(data);
  for (var i = 0; i &lt; data.length; i++) {
    var n = data[i];

    // check for carry over of a multi byte char split between data chunks
    // &amp; fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
    if (this.bytes_remaining &gt; 0) {
      for (var j = 0; j &lt; this.bytes_remaining; j++) {
        this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];
      }
      this.string = this.temp_buffs[this.bytes_in_sequence].toString();
      this.bytes_in_sequence = this.bytes_remaining = 0;

      // move iterator forward by number of byte read during sequencing
      i = i + j - 1;

      // pass data to parser and move forward to parse rest of data
      this._parser.write(this.string);
      this.emit("data", this.string);
      continue;
    }

    // if no remainder bytes carried over, parse multi byte (&gt;=128) chars one at a time
    if (this.bytes_remaining === 0 &amp;&amp; n &gt;= 128) {
      if ((n &gt;= 194) &amp;&amp; (n &lt;= 223)) this.bytes_in_sequence = 2;
      if ((n &gt;= 224) &amp;&amp; (n &lt;= 239)) this.bytes_in_sequence = 3;
      if ((n &gt;= 240) &amp;&amp; (n &lt;= 244)) this.bytes_in_sequence = 4;
      if ((this.bytes_in_sequence + i) &gt; data.length) { // if bytes needed to complete char fall outside data length, we have a
boundary split

        for (var k = 0; k &lt;= (data.length - 1 - i); k++) {
          this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this
 chunk
        }
        this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;

        // immediately return as we need another chunk to sequence the character
        return true;
      } else {
        this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();
        i = i + this.bytes_in_sequence - 1;

        this._parser.write(this.string);
        this.emit("data", this.string);
        continue;
      }
    }

    // is there a range of characters that are immediately parsable?
    for (var p = i; p &lt; data.length; p++) {
      if (data[p] &gt;= 128) break;
    }
    this.string = data.slice(i, p).toString();
    this._parser.write(this.string);
    this.emit("data", this.string);
    i = p - 1;

    // handle any remaining characters using multibyte logic
    continue;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.createStream" id="apidoc.element.clarinet.createStream">
        function <span class="apidocSignatureSpan">clarinet.</span>createStream
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStream(opt) { return new CStream(opt); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

parser.write('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").<span class="apidocCodeKeywordSpan">createStream</span>(options);
stream.on("error", function (e) {
// unhandled errors will throw, since this is a proper node
// event emitter.
console.error("error!", e)
// clear the error
this._parser.error = null
this._parser.resume()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.parser" id="apidoc.element.clarinet.parser">
        function <span class="apidocSignatureSpan">clarinet.</span>parser
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function (opt) { return new CParser(opt);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# usage

## basics

``` js
var clarinet = require("clarinet")
, parser = clarinet.<span class="apidocCodeKeywordSpan">parser</span>()
;

parser.onerror = function (e) {
// an error happened. e is the error.
};
parser.onvalue = function (v) {
// got some value.  v is the value. can be string, double, bool, or null.
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CParser" id="apidoc.module.clarinet.CParser">module clarinet.CParser</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CParser.CParser" id="apidoc.element.clarinet.CParser.CParser">
        function <span class="apidocSignatureSpan">clarinet.</span>CParser
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CParser(opt) {
  if (!(this instanceof CParser)) return new CParser (opt);

  var parser = this;
  clearBuffers(parser);
  parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;
  parser.q        = parser.c = parser.p = "";
  parser.opt      = opt || {};
  parser.closed   = parser.closedRoot = parser.sawRoot = false;
  parser.tag      = parser.error = null;
  parser.state    = S.BEGIN;
  parser.stack    = new Array();
  // mostly just for error reporting
  parser.position = parser.column = 0;
  parser.line     = 1;
  parser.slashed  = false;
  parser.unicodeI = 0;
  parser.unicodeS = null;
  parser.depth    = 0;
  emit(parser, "onready");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CParser.prototype" id="apidoc.module.clarinet.CParser.prototype">module clarinet.CParser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.close" id="apidoc.element.clarinet.CParser.prototype.close">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () { return this.write(null); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onclosearray = function () {
  // closed an array.
};
parser.onend = function () {
  // parser stream is done, and ready to have more stuff written to it.
};

parser.write('{"foo": "bar"}').<span class="apidocCodeKeywordSpan">close</span>();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.end" id="apidoc.element.clarinet.CParser.prototype.end">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () { end(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.resume" id="apidoc.element.clarinet.CParser.prototype.resume">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () { this.error = null; return this; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
  // unhandled errors will throw, since this is a proper node
  // event emitter.
  console.error("error!", e)
  // clear the error
  this._parser.error = null
  this._parser.<span class="apidocCodeKeywordSpan">resume</span>()
})
stream.on("openobject", function (node) {
  // same object as above
})
// pipe is supported, and it's readable/writable
// same chunks coming in also go out.
fs.createReadStream("file.json")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.write" id="apidoc.element.clarinet.CParser.prototype.write">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(chunk) {
  var parser = this;
  if (this.error) throw this.error;
  if (parser.closed) return error(parser,
    "Cannot write after close. Assign an onready handler.");
  if (chunk === null) return end(parser);
  var i = 0, c = chunk[0], p = parser.p;
  if (clarinet.DEBUG) console.log('write -&gt; [' + chunk + ']');
  while (c) {
    p = c;
    parser.c = c = chunk.charAt(i++);
    // if chunk doesnt have next, like streaming char by char
    // this way we need to check if previous is really previous
    // if not we need to reset to what the parser says is the previous
    // from buffer
    if(p !== c ) parser.p = p;
    else p = parser.p;

    if(!c) break;

    if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);
    parser.position ++;
    if (c === "\n") {
      parser.line ++;
      parser.column = 0;
    } else parser.column ++;
    switch (parser.state) {

      case S.BEGIN:
        if (c === "{") parser.state = S.OPEN_OBJECT;
        else if (c === "[") parser.state = S.OPEN_ARRAY;
        else if (c !== '\r' &amp;&amp; c !== '\n' &amp;&amp; c !== ' ' &amp;&amp; c !== '\t')
          error(parser, "Non-whitespace before {[.");
      continue;

      case S.OPEN_KEY:
      case S.OPEN_OBJECT:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);
        else {
          if(c === '}') {
            emit(parser, 'onopenobject');
            this.depth++;
            emit(parser, 'oncloseobject');
            this.depth--;
            parser.state = parser.stack.pop() || S.VALUE;
            continue;
          } else  parser.stack.push(S.CLOSE_OBJECT);
        }
        if(c === '"') parser.state = S.STRING;
        else error(parser, "Malformed object key should start with \"");
      continue;

      case S.CLOSE_KEY:
      case S.CLOSE_OBJECT:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';
        if(c===':') {
          if(parser.state === S.CLOSE_OBJECT) {
            parser.stack.push(S.CLOSE_OBJECT);
            closeValue(parser, 'onopenobject');
             this.depth++;
          } else closeValue(parser, 'onkey');
          parser.state  = S.VALUE;
        } else if (c==='}') {
          emitNode(parser, 'oncloseobject');
          this.depth--;
          parser.state = parser.stack.pop() || S.VALUE;
        } else if(c===',') {
          if(parser.state === S.CLOSE_OBJECT)
            parser.stack.push(S.CLOSE_OBJECT);
          closeValue(parser);
          parser.state  = S.OPEN_KEY;
        } else error(parser, 'Bad object');
      continue;

      case S.OPEN_ARRAY: // after an array there always a value
      case S.VALUE:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        if(parser.state===S.OPEN_ARRAY) {
          emit(parser, 'onopenarray');
          this.depth++;
          parser.state = S.VALUE;
          if(c === ']') {
            emit(parser, 'onclosearray');
            this.depth--;
            parser.state = parser.stack.pop() || S.VALUE;
            continue;
          } else {
            parser.stack.push(S.CLOSE_ARRAY);
          }
        }
             if(c === '"') parser.state = S.STRING;
        else if(c === '{') parser.state = S.OPEN_OBJECT;
        else if(c === '[') parser.state = S.OPEN_ARRAY;
        else if(c === 't') parser.state = S.TRUE;
        else if(c === 'f') parser.state = S.FALSE;
        else if(c === 'n') parser.state = S.NULL;
        else if(c === '-') { // keep and continue
          parser.numberNode += c;
        } else if(c==='0') {
          parser.numberNode += c;
          parser.state = S.NUMBER_DIGIT;
        } else if('123456789'.indexOf(c) !== -1) {
          parser.numberNode += c;
          parser.state = S.NUMBER_DIGIT;
        } else               error(parser, "Bad value");
      continue;

      case S.CLOSE_ARRAY:
        if(c===',') {
          parser.stack.push(S.CLOSE_ARRAY);
          closeValue(parser, 'onval ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onclosearray = function () {
  // closed an array.
};
parser.onend = function () {
  // parser stream is done, and ready to have more stuff written to it.
};

parser.<span class="apidocCodeKeywordSpan">write</span>('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CParser.prototype.close" id="apidoc.module.clarinet.CParser.prototype.close">module clarinet.CParser.prototype.close</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.close.close" id="apidoc.element.clarinet.CParser.prototype.close.close">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function () { return this.write(null); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onclosearray = function () {
  // closed an array.
};
parser.onend = function () {
  // parser stream is done, and ready to have more stuff written to it.
};

parser.write('{"foo": "bar"}').<span class="apidocCodeKeywordSpan">close</span>();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CParser.prototype.end" id="apidoc.module.clarinet.CParser.prototype.end">module clarinet.CParser.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.end.end" id="apidoc.element.clarinet.CParser.prototype.end.end">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () { end(this); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CParser.prototype.resume" id="apidoc.module.clarinet.CParser.prototype.resume">module clarinet.CParser.prototype.resume</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.resume.resume" id="apidoc.element.clarinet.CParser.prototype.resume.resume">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () { this.error = null; return this; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
  // unhandled errors will throw, since this is a proper node
  // event emitter.
  console.error("error!", e)
  // clear the error
  this._parser.error = null
  this._parser.<span class="apidocCodeKeywordSpan">resume</span>()
})
stream.on("openobject", function (node) {
  // same object as above
})
// pipe is supported, and it's readable/writable
// same chunks coming in also go out.
fs.createReadStream("file.json")
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CParser.prototype.write" id="apidoc.module.clarinet.CParser.prototype.write">module clarinet.CParser.prototype.write</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CParser.prototype.write.write" id="apidoc.element.clarinet.CParser.prototype.write.write">
        function <span class="apidocSignatureSpan">clarinet.CParser.prototype.</span>write
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(chunk) {
  var parser = this;
  if (this.error) throw this.error;
  if (parser.closed) return error(parser,
    "Cannot write after close. Assign an onready handler.");
  if (chunk === null) return end(parser);
  var i = 0, c = chunk[0], p = parser.p;
  if (clarinet.DEBUG) console.log('write -&gt; [' + chunk + ']');
  while (c) {
    p = c;
    parser.c = c = chunk.charAt(i++);
    // if chunk doesnt have next, like streaming char by char
    // this way we need to check if previous is really previous
    // if not we need to reset to what the parser says is the previous
    // from buffer
    if(p !== c ) parser.p = p;
    else p = parser.p;

    if(!c) break;

    if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);
    parser.position ++;
    if (c === "\n") {
      parser.line ++;
      parser.column = 0;
    } else parser.column ++;
    switch (parser.state) {

      case S.BEGIN:
        if (c === "{") parser.state = S.OPEN_OBJECT;
        else if (c === "[") parser.state = S.OPEN_ARRAY;
        else if (c !== '\r' &amp;&amp; c !== '\n' &amp;&amp; c !== ' ' &amp;&amp; c !== '\t')
          error(parser, "Non-whitespace before {[.");
      continue;

      case S.OPEN_KEY:
      case S.OPEN_OBJECT:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);
        else {
          if(c === '}') {
            emit(parser, 'onopenobject');
            this.depth++;
            emit(parser, 'oncloseobject');
            this.depth--;
            parser.state = parser.stack.pop() || S.VALUE;
            continue;
          } else  parser.stack.push(S.CLOSE_OBJECT);
        }
        if(c === '"') parser.state = S.STRING;
        else error(parser, "Malformed object key should start with \"");
      continue;

      case S.CLOSE_KEY:
      case S.CLOSE_OBJECT:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';
        if(c===':') {
          if(parser.state === S.CLOSE_OBJECT) {
            parser.stack.push(S.CLOSE_OBJECT);
            closeValue(parser, 'onopenobject');
             this.depth++;
          } else closeValue(parser, 'onkey');
          parser.state  = S.VALUE;
        } else if (c==='}') {
          emitNode(parser, 'oncloseobject');
          this.depth--;
          parser.state = parser.stack.pop() || S.VALUE;
        } else if(c===',') {
          if(parser.state === S.CLOSE_OBJECT)
            parser.stack.push(S.CLOSE_OBJECT);
          closeValue(parser);
          parser.state  = S.OPEN_KEY;
        } else error(parser, 'Bad object');
      continue;

      case S.OPEN_ARRAY: // after an array there always a value
      case S.VALUE:
        if (c === '\r' || c === '\n' || c === ' ' || c === '\t') continue;
        if(parser.state===S.OPEN_ARRAY) {
          emit(parser, 'onopenarray');
          this.depth++;
          parser.state = S.VALUE;
          if(c === ']') {
            emit(parser, 'onclosearray');
            this.depth--;
            parser.state = parser.stack.pop() || S.VALUE;
            continue;
          } else {
            parser.stack.push(S.CLOSE_ARRAY);
          }
        }
             if(c === '"') parser.state = S.STRING;
        else if(c === '{') parser.state = S.OPEN_OBJECT;
        else if(c === '[') parser.state = S.OPEN_ARRAY;
        else if(c === 't') parser.state = S.TRUE;
        else if(c === 'f') parser.state = S.FALSE;
        else if(c === 'n') parser.state = S.NULL;
        else if(c === '-') { // keep and continue
          parser.numberNode += c;
        } else if(c==='0') {
          parser.numberNode += c;
          parser.state = S.NUMBER_DIGIT;
        } else if('123456789'.indexOf(c) !== -1) {
          parser.numberNode += c;
          parser.state = S.NUMBER_DIGIT;
        } else               error(parser, "Bad value");
      continue;

      case S.CLOSE_ARRAY:
        if(c===',') {
          parser.stack.push(S.CLOSE_ARRAY);
          closeValue(parser, 'onval ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onclosearray = function () {
  // closed an array.
};
parser.onend = function () {
  // parser stream is done, and ready to have more stuff written to it.
};

parser.<span class="apidocCodeKeywordSpan">write</span>('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CStream" id="apidoc.module.clarinet.CStream">module clarinet.CStream</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CStream.CStream" id="apidoc.element.clarinet.CStream.CStream">
        function <span class="apidocSignatureSpan">clarinet.</span>CStream
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CStream(opt) {
  if (!(this instanceof CStream)) return new CStream(opt);

  this._parser = new CParser(opt);
  this.writable = true;
  this.readable = true;

  //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer`
and not throw an error
  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
  this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary
 is reached
  this.string = '';

  var me = this;
  Stream.apply(me);

  this._parser.onend = function () { me.emit("end"); };
  this._parser.onerror = function (er) {
    me.emit("error", er);
    me._parser.error = null;
  };

  streamWraps.forEach(function (ev) {
    Object.defineProperty(me, "on" + ev,
      { get          : function () { return me._parser["on" + ev]; }
      , set          : function (h) {
          if (!h) {
            me.removeAllListeners(ev);
            me._parser["on"+ev] = h;
            return h;
          }
          me.on(ev, h);
        }
      , enumerable   : true
      , configurable : false
      });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CStream.prototype" id="apidoc.module.clarinet.CStream.prototype">module clarinet.CStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.destroy" id="apidoc.element.clarinet.CStream.prototype.destroy">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  clearBuffers(this._parser);
  this.emit("close");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.end" id="apidoc.element.clarinet.CStream.prototype.end">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) this._parser.write(chunk.toString());
  this._parser.end();
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.on" id="apidoc.element.clarinet.CStream.prototype.on">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, handler) {
  var me = this;
  if (!me._parser["on"+ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser["on"+ev] = function () {
      var args = arguments.length === 1 ? [arguments[0]]
               : Array.apply(null, arguments);
      args.splice(0, 0, ev);
      me.emit.apply(me, args);
    };
  }
  return Stream.prototype.on.call(me, ev, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.write('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.<span class="apidocCodeKeywordSpan">on</span>("error", function (e) {
  // unhandled errors will throw, since this is a proper node
  // event emitter.
  console.error("error!", e)
  // clear the error
  this._parser.error = null
  this._parser.resume()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.write" id="apidoc.element.clarinet.CStream.prototype.write">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
  data = new Buffer(data);
  for (var i = 0; i &lt; data.length; i++) {
    var n = data[i];

    // check for carry over of a multi byte char split between data chunks
    // &amp; fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
    if (this.bytes_remaining &gt; 0) {
      for (var j = 0; j &lt; this.bytes_remaining; j++) {
        this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];
      }
      this.string = this.temp_buffs[this.bytes_in_sequence].toString();
      this.bytes_in_sequence = this.bytes_remaining = 0;

      // move iterator forward by number of byte read during sequencing
      i = i + j - 1;

      // pass data to parser and move forward to parse rest of data
      this._parser.write(this.string);
      this.emit("data", this.string);
      continue;
    }

    // if no remainder bytes carried over, parse multi byte (&gt;=128) chars one at a time
    if (this.bytes_remaining === 0 &amp;&amp; n &gt;= 128) {
      if ((n &gt;= 194) &amp;&amp; (n &lt;= 223)) this.bytes_in_sequence = 2;
      if ((n &gt;= 224) &amp;&amp; (n &lt;= 239)) this.bytes_in_sequence = 3;
      if ((n &gt;= 240) &amp;&amp; (n &lt;= 244)) this.bytes_in_sequence = 4;
      if ((this.bytes_in_sequence + i) &gt; data.length) { // if bytes needed to complete char fall outside data length, we have a
boundary split

        for (var k = 0; k &lt;= (data.length - 1 - i); k++) {
          this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this
 chunk
        }
        this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;

        // immediately return as we need another chunk to sequence the character
        return true;
      } else {
        this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();
        i = i + this.bytes_in_sequence - 1;

        this._parser.write(this.string);
        this.emit("data", this.string);
        continue;
      }
    }

    // is there a range of characters that are immediately parsable?
    for (var p = i; p &lt; data.length; p++) {
      if (data[p] &gt;= 128) break;
    }
    this.string = data.slice(i, p).toString();
    this._parser.write(this.string);
    this.emit("data", this.string);
    i = p - 1;

    // handle any remaining characters using multibyte logic
    continue;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onclosearray = function () {
  // closed an array.
};
parser.onend = function () {
  // parser stream is done, and ready to have more stuff written to it.
};

parser.<span class="apidocCodeKeywordSpan">write</span>('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CStream.prototype.destroy" id="apidoc.module.clarinet.CStream.prototype.destroy">module clarinet.CStream.prototype.destroy</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.destroy.destroy" id="apidoc.element.clarinet.CStream.prototype.destroy.destroy">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  clearBuffers(this._parser);
  this.emit("close");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CStream.prototype.end" id="apidoc.module.clarinet.CStream.prototype.end">module clarinet.CStream.prototype.end</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.end.end" id="apidoc.element.clarinet.CStream.prototype.end.end">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>end
        <span class="apidocSignatureSpan">(chunk)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function (chunk) {
  if (chunk &amp;&amp; chunk.length) this._parser.write(chunk.toString());
  this._parser.end();
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CStream.prototype.on" id="apidoc.module.clarinet.CStream.prototype.on">module clarinet.CStream.prototype.on</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.on.on" id="apidoc.element.clarinet.CStream.prototype.on.on">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>on
        <span class="apidocSignatureSpan">(ev, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (ev, handler) {
  var me = this;
  if (!me._parser["on"+ev] &amp;&amp; streamWraps.indexOf(ev) !== -1) {
    me._parser["on"+ev] = function () {
      var args = arguments.length === 1 ? [arguments[0]]
               : Array.apply(null, arguments);
      args.splice(0, 0, ev);
      me.emit.apply(me, args);
    };
  }
  return Stream.prototype.on.call(me, ev, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.write('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.<span class="apidocCodeKeywordSpan">on</span>("error", function (e) {
  // unhandled errors will throw, since this is a proper node
  // event emitter.
  console.error("error!", e)
  // clear the error
  this._parser.error = null
  this._parser.resume()
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.CStream.prototype.write" id="apidoc.module.clarinet.CStream.prototype.write">module clarinet.CStream.prototype.write</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.CStream.prototype.write.write" id="apidoc.element.clarinet.CStream.prototype.write.write">
        function <span class="apidocSignatureSpan">clarinet.CStream.prototype.</span>write
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (data) {
  data = new Buffer(data);
  for (var i = 0; i &lt; data.length; i++) {
    var n = data[i];

    // check for carry over of a multi byte char split between data chunks
    // &amp; fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
    if (this.bytes_remaining &gt; 0) {
      for (var j = 0; j &lt; this.bytes_remaining; j++) {
        this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];
      }
      this.string = this.temp_buffs[this.bytes_in_sequence].toString();
      this.bytes_in_sequence = this.bytes_remaining = 0;

      // move iterator forward by number of byte read during sequencing
      i = i + j - 1;

      // pass data to parser and move forward to parse rest of data
      this._parser.write(this.string);
      this.emit("data", this.string);
      continue;
    }

    // if no remainder bytes carried over, parse multi byte (&gt;=128) chars one at a time
    if (this.bytes_remaining === 0 &amp;&amp; n &gt;= 128) {
      if ((n &gt;= 194) &amp;&amp; (n &lt;= 223)) this.bytes_in_sequence = 2;
      if ((n &gt;= 224) &amp;&amp; (n &lt;= 239)) this.bytes_in_sequence = 3;
      if ((n &gt;= 240) &amp;&amp; (n &lt;= 244)) this.bytes_in_sequence = 4;
      if ((this.bytes_in_sequence + i) &gt; data.length) { // if bytes needed to complete char fall outside data length, we have a
boundary split

        for (var k = 0; k &lt;= (data.length - 1 - i); k++) {
          this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this
 chunk
        }
        this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;

        // immediately return as we need another chunk to sequence the character
        return true;
      } else {
        this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();
        i = i + this.bytes_in_sequence - 1;

        this._parser.write(this.string);
        this.emit("data", this.string);
        continue;
      }
    }

    // is there a range of characters that are immediately parsable?
    for (var p = i; p &lt; data.length; p++) {
      if (data[p] &gt;= 128) break;
    }
    this.string = data.slice(i, p).toString();
    this._parser.write(this.string);
    this.emit("data", this.string);
    i = p - 1;

    // handle any remaining characters using multibyte logic
    continue;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parser.onclosearray = function () {
  // closed an array.
};
parser.onend = function () {
  // parser stream is done, and ready to have more stuff written to it.
};

parser.<span class="apidocCodeKeywordSpan">write</span>('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").createStream(options);
stream.on("error", function (e) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.createStream" id="apidoc.module.clarinet.createStream">module clarinet.createStream</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.createStream.createStream" id="apidoc.element.clarinet.createStream.createStream">
        function <span class="apidocSignatureSpan">clarinet.</span>createStream
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createStream(opt) { return new CStream(opt); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

parser.write('{"foo": "bar"}').close();
```

``` js
// stream usage
// takes the same options as the parser
var stream = require("clarinet").<span class="apidocCodeKeywordSpan">createStream</span>(options);
stream.on("error", function (e) {
// unhandled errors will throw, since this is a proper node
// event emitter.
console.error("error!", e)
// clear the error
this._parser.error = null
this._parser.resume()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.clarinet.parser" id="apidoc.module.clarinet.parser">module clarinet.parser</a></h1>


    <h2>
        <a href="#apidoc.element.clarinet.parser.parser" id="apidoc.element.clarinet.parser.parser">
        function <span class="apidocSignatureSpan">clarinet.</span>parser
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function (opt) { return new CParser(opt);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# usage

## basics

``` js
var clarinet = require("clarinet")
, parser = clarinet.<span class="apidocCodeKeywordSpan">parser</span>()
;

parser.onerror = function (e) {
// an error happened. e is the error.
};
parser.onvalue = function (v) {
// got some value.  v is the value. can be string, double, bool, or null.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>